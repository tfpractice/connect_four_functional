{"version":3,"file":"bundle.cjs.js","sources":["../node_modules/graph-curry/dist/bundle.es6.js","../src/node.js","../src/board.js","../src/player.js","../src/utils/commands.js"],"sourcesContent":["import { collections } from 'turmeric-utils';\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar addBinMap = collections.addBinMap;\nvar mapDiff = collections.mapDiff;\nvar spread = collections.spread;\nvar addMap = collections.addMap;\nvar get$$1 = collections.get;\nvar flatTuple = collections.flatTuple;\nvar removeMap = collections.removeMap;\n\n\nvar resetNodeBin = function resetNodeBin(edges, src) {\n  return addMap(edges)(src)(new Map());\n};\n\nvar addNodeBin = function addNodeBin(edges, src) {\n  return addMap(edges)(src)(new Map(get$$1(edges)(src)));\n};\n\nvar addEdgeBin = function addEdgeBin(edges, _ref) {\n  var _ref2 = slicedToArray(_ref, 3),\n      src = _ref2[0],\n      nb = _ref2[1],\n      _ref2$ = _ref2[2],\n      wt = _ref2$ === undefined ? 0 : _ref2$;\n\n  return [[src, addMap(get$$1(edges)(src))(nb)(wt)], [nb, addMap(get$$1(edges)(nb))(src)(wt)]].reduce(addBinMap, new Map(edges));\n};\n\nvar removeEdgeBin = function removeEdgeBin(edges, _ref3) {\n  var _ref4 = slicedToArray(_ref3, 2),\n      src = _ref4[0],\n      nb = _ref4[1];\n\n  return [[src, removeMap(get$$1(edges)(src))(nb)], [nb, removeMap(get$$1(edges)(nb))(src)]].reduce(addBinMap, new Map(edges));\n};\n\nvar importEdgeBin = function importEdgeBin(edges, _ref5) {\n  var _ref6 = slicedToArray(_ref5, 2),\n      src = _ref6[0],\n      nbs = _ref6[1];\n\n  return spread(mapDiff(nbs)(get$$1(edges)(src))).map(flatTuple(src)).reduce(addEdgeBin, addNodeBin(edges, src));\n};\n\nvar mergeEdgesBin = function mergeEdgesBin(edges, alts) {\n  return spread(new Map(alts)).reduce(importEdgeBin, edges);\n};\n\nvar triple = collections.triple;\nvar tuple = collections.tuple;\nvar get$2 = collections.get;\nvar spreadK = collections.spreadK;\nvar hasK = collections.hasK;\nvar addBinMap$1 = collections.addBinMap;\nvar removeBin = collections.removeBin;\nvar uniteMap = collections.uniteMap;\n\n\nvar spawn = function spawn(edges) {\n  return new Map(edges);\n};\nvar copy = spawn;\nvar fromElements = function fromElements() {\n  for (var _len = arguments.length, elems = Array(_len), _key = 0; _key < _len; _key++) {\n    elems[_key] = arguments[_key];\n  }\n\n  return elems.reduce(addNodeBin, copy());\n};\nvar nodes = function nodes(edges) {\n  return spreadK(copy(edges));\n};\nvar adj = function adj(edges) {\n  return function (src) {\n    return copy(get$2(edges)(src));\n  };\n};\nvar neighbors = function neighbors(edges) {\n  return function (src) {\n    return nodes(adj(edges)(src));\n  };\n};\nvar contains = function contains(edges) {\n  return function (node) {\n    return hasK(edges)(node);\n  };\n};\nvar isAdjacent = function isAdjacent(edges) {\n  return function (src) {\n    return function (nabe) {\n      return contains(adj(edges)(src))(nabe);\n    };\n  };\n};\n\nvar addNodes = function addNodes(edges) {\n  return function () {\n    for (var _len2 = arguments.length, srcs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      srcs[_key2] = arguments[_key2];\n    }\n\n    return srcs.reduce(addNodeBin, edges);\n  };\n};\nvar removeNodes = function removeNodes(edges) {\n  return function () {\n    for (var _len3 = arguments.length, srcs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      srcs[_key3] = arguments[_key3];\n    }\n\n    return srcs.reduce(removeBin, copy(edges));\n  };\n};\nvar resetNodes = function resetNodes(edges) {\n  return function () {\n    for (var _len4 = arguments.length, srcs = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      srcs[_key4] = arguments[_key4];\n    }\n\n    return srcs.reduce(resetNodeBin, edges);\n  };\n};\n\nvar addEdges = function addEdges(edges) {\n  return function (src) {\n    var w = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return function () {\n      for (var _len5 = arguments.length, nabes = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        nabes[_key5] = arguments[_key5];\n      }\n\n      return nabes.map(triple(w)(src)).reduce(addEdgeBin, edges);\n    };\n  };\n};\n\nvar removeEdges = function removeEdges(edges) {\n  return function (src) {\n    return function () {\n      for (var _len6 = arguments.length, nabes = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        nabes[_key6] = arguments[_key6];\n      }\n\n      return nabes.map(tuple(src)).reduce(removeEdgeBin, edges);\n    };\n  };\n};\n\nvar mergeEdges = function mergeEdges(edges) {\n  return function () {\n    for (var _len7 = arguments.length, alts = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      alts[_key7] = arguments[_key7];\n    }\n\n    return alts.reduce(mergeEdgesBin, edges);\n  };\n};\n\nvar addNeighbor = function addNeighbor(edges) {\n  return function (src) {\n    return function (n) {\n      var w = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return addBinMap$1(adj(edges)(src), [n, w]);\n    };\n  };\n};\n\nvar addEntry = function addEntry(nabes) {\n  return function (_ref) {\n    var _ref2 = slicedToArray(_ref, 2),\n        n = _ref2[0],\n        _ref2$ = _ref2[1],\n        w = _ref2$ === undefined ? 0 : _ref2$;\n\n    return addBinMap$1(nabes, [n, w]);\n  };\n};\n\nvar mergeNeighbors = uniteMap;\n\nvar addBinSet = collections.addBinSet;\nvar lastK = collections.lastK;\nvar hasK$1 = collections.hasK;\nvar mapDiff$1 = collections.mapDiff;\nvar diff = collections.diff;\nvar addBinMap$2 = collections.addBinMap;\nvar spread$1 = collections.spread;\nvar spreadK$1 = collections.spreadK;\nvar spreadV = collections.spreadV;\nvar popFirst = collections.popFirst;\nvar tuple$1 = collections.tuple;\n\n\nvar pathVal = function pathVal() {\n  var pred = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  return function () {\n    var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    return function () {\n      var weight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return { pred: pred, length: length, weight: weight };\n    };\n  };\n};\n\nvar addSrc = function addSrc() {\n  var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Map();\n  return function (src) {\n    return path.set(src, { pred: lastK(path), weight: 0, length: 1 });\n  };\n};\n\nvar initPath = function initPath(node) {\n  return addSrc()(node);\n};\nvar ptW = function ptW(_ref) {\n  var _ref$weight = _ref.weight,\n      weight = _ref$weight === undefined ? 0 : _ref$weight;\n  return weight;\n};\nvar ptL = function ptL(_ref2) {\n  var _ref2$length = _ref2.length,\n      length = _ref2$length === undefined ? 1 : _ref2$length;\n  return length;\n};\nvar lastVal = function lastVal(path) {\n  return path.get(lastK(path));\n};\nvar lastW = function lastW(path) {\n  return ptW(lastVal(path));\n};\nvar lastL = function lastL(path) {\n  return ptL(lastVal(path));\n};\nvar nextW = function nextW(path) {\n  return function () {\n    var w = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return lastW(path) + w;\n  };\n};\nvar nextL = function nextL(path) {\n  return lastL(path) ? lastL(path) + 1 : 1;\n};\n\nvar nextPath = function nextPath() {\n  var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Map();\n  var _ref3 = arguments[1];\n\n  var _ref4 = slicedToArray(_ref3, 2),\n      n = _ref4[0],\n      _ref4$ = _ref4[1],\n      w = _ref4$ === undefined ? 0 : _ref4$;\n\n  return path.set(n, pathVal(lastK(path))(nextL(path))(nextW(path)(w)));\n};\n\nvar dfs = function dfs(edges) {\n  return function (src) {\n    var trav = function trav() {\n      var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initPath(src);\n\n      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [lastK(path), 0],\n          _ref6 = slicedToArray(_ref5, 2),\n          n = _ref6[0],\n          w = _ref6[1];\n\n      return spread$1(mapDiff$1(edges.get(n))(path)).reduce(trav, nextPath(path, [n, w]));\n    };\n\n    return trav(initPath(src));\n  };\n};\n\nvar bfs = function bfs(edges) {\n  return function (iNode) {\n    var bVisit = function bVisit(bPath) {\n      return function (bQueue) {\n        var pred = popFirst(bQueue);\n        var nextNabes = mapDiff$1(edges.get(pred))(bPath);\n\n        spread$1(nextNabes).reduce(nextPath, bPath);\n        spreadK$1(nextNabes).reduce(addBinSet, bQueue);\n        return bQueue.size > 0 ? bVisit(bPath)(bQueue) : bPath;\n      };\n    };\n\n    return bVisit(initPath(iNode))(new Set([iNode]));\n  };\n};\n\nvar dijkstra = function dijkstra(edges) {\n  return function (iNode) {\n    var reachables = bfs(edges)(iNode);\n    var inspectQueue = new Set([iNode]);\n    var solutionSet = initPath(iNode);\n\n    while (inspectQueue.size > 0) {\n      var pred = popFirst(inspectQueue);\n      var nextNabes = edges.get(pred);\n\n      var _solutionSet$get = solutionSet.get(pred),\n          dCount = _solutionSet$get.length,\n          dWeight = _solutionSet$get.weight;\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n\n        for (var _iterator = nextNabes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _step$value = slicedToArray(_step.value, 2),\n              nabe = _step$value[0],\n              nWeight = _step$value[1];\n\n          var prevMap = reachables.get(nabe) || { length: 1, weight: 0 };\n          var rCount = prevMap.length,\n              rWeight = prevMap.weight;\n\n          var dMap = { pred: pred, length: dCount + 1, weight: dWeight + nWeight };\n          var sMap = dWeight + nWeight < rWeight ? dMap : prevMap;\n\n          if (!solutionSet.has(nabe)) {\n            inspectQueue.add(nabe);\n            solutionSet.set(nabe, sMap);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n\n    return solutionSet;\n  };\n};\n\nvar components = function components(edges) {\n  var trav = function trav() {\n    var comp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Set();\n    var node = arguments[1];\n    return diff(spreadK$1(edges.get(node)))(comp).reduce(trav, comp.add(node));\n  };\n  var visitMap = function visitMap() {\n    var mMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Map();\n    var node = arguments[1];\n    return diff(trav(new Set(), node))(mMap).map(tuple$1(trav(new Set(), node))).reduce(addBinMap$2, mMap);\n  };\n\n  return spreadK$1(edges).reduce(visitMap, new Map());\n};\n\nvar componentSet = function componentSet(edges) {\n  return new Set(spreadV(components(edges)));\n};\nvar pathBetween = function pathBetween(edges) {\n  return function (n0) {\n    return function (n1) {\n      return hasK$1(components(edges).get(n1))(n0);\n    };\n  };\n};\n\nvar spread$2 = collections.spread;\nvar spreadK$2 = collections.spreadK;\nvar spreadV$1 = collections.spreadV;\nvar spreadKV = collections.spreadKV;\nvar last = collections.last;\n\n\nvar redStr = function redStr() {\n  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ' ';\n  var val = arguments[1];\n  var id = arguments[2];\n  var coll = arguments[3];\n  return val === last(coll) ? str.concat(val, ' ') : str.concat(val, ' , ');\n};\nvar collString = function collString(coll) {\n  return spread$2(coll).reduce(redStr, '');\n};\nvar kString = function kString(coll) {\n  return spreadK$2(coll).reduce(redStr, '');\n};\nvar vString = function vString(coll) {\n  return spreadV$1(coll).reduce(redStr, '');\n};\nvar kvString = function kvString(coll) {\n  return spreadKV(coll).reduce(redStr, '');\n};\n\nvar pathString = function pathString(path) {\n  return ' { ' + spreadK$2(path).join(' => ') + ' }';\n};\nvar edgeString = function edgeString(_ref) {\n  var _ref2 = slicedToArray(_ref, 2),\n      src = _ref2[0],\n      nbs = _ref2[1];\n\n  return '{ Edge ' + src + ' >> [ ' + kString(nbs) + ' ] } ';\n};\n\nvar componentString = function componentString(_ref3) {\n  var _ref4 = slicedToArray(_ref3, 2),\n      node = _ref4[0],\n      nbs = _ref4[1];\n\n  return '{ component ' + node + ' >> [ ' + kString(nbs) + ' ] } ';\n};\n\nvar graphString = function graphString(edges) {\n  return spreadKV(edges).reduce(function (str, _ref5, id) {\n    var _ref6 = slicedToArray(_ref5, 2),\n        node = _ref6[0],\n        nabes = _ref6[1];\n\n    return str + edgeString([node, nabes]);\n  }, 'Showing Edges\\n');\n};\n\nvar showGraph = function showGraph(_ref7) {\n  var edges = _ref7.edges;\n  return graphString(edges);\n};\n\n// export { Graph, Reducers, Search, Show, };\n\nexport { resetNodeBin, addNodeBin, addEdgeBin, removeEdgeBin, importEdgeBin, mergeEdgesBin, spawn, copy, fromElements, nodes, adj, neighbors, contains, isAdjacent, addNodes, removeNodes, resetNodes, addEdges, removeEdges, mergeEdges, addNeighbor, addEntry, mergeNeighbors, dfs, bfs, dijkstra, components, componentSet, pathBetween, redStr, collString, kString, vString, kvString, pathString, edgeString, componentString, graphString, showGraph };export default fromElements;\n//# sourceMappingURL=bundle.es6.js.map\n","import { node, } from 'game_grid';\n\nexport default (c = 0, r = 0, player = null) =>\nObject.assign(node(c, r), { player });\n\nexport const player = ({ player = null }) => player;\nexport const isFree = ({ player = null }) => player === null;\nexport const samePlayer = ({ player: p0 }) => ({ player: p1 }) => p0 === p1;\n","import { collections, } from 'turmeric-utils';\nimport { fromElements, nodes, } from 'graph-curry';\nimport { colComponents, genNodes as generate, grid, negComponents,\n   posComponents, rowComponents, } from 'game_grid';\nimport node, { isFree, samePlayer, } from './node';\nconst { flatten, flatTuple, spreadV, } = collections;\n\nconst flattenBin = (a = [], b = []) => flatten(a)(b);\n\nexport default fromElements;\n\nexport const genNodes = (cols = 7, rows = 6) =>\ngenerate(cols, rows).map(n => node(n.column, n.row));\n\nexport const initNodes = (c = 7, r = 6) => fromElements(...genNodes(c, r));\nexport const next = nodes => nodes.find(isFree);\nexport const hasFree = nodes => nodes.some(isFree);\n\nexport const nodesByPlayer = graph => (player = null) =>\n  nodes(graph).filter(samePlayer({ player }));\n\nexport const playerGraph = (gr = new Map) => p =>\n  fromElements(...nodesByPlayer(gr)(p));\n\nexport const allComps = graph => [\n  colComponents, negComponents, posComponents, rowComponents,\n].map(f => f(graph)).reduce(flattenBin, []);\n\nexport const splitComps = g => new Map()\n  .set('row', rowComponents(g)).set('col', colComponents(g))\n  .set('pos', posComponents(g)).set('neg', negComponents(g));\n\nexport const moreThan = num => (coll = new Set) => coll.size > num;\nexport const winComp = (graph, n = 3) => allComps(graph).some(moreThan(n));\n\n//\n// module.exports = Object.assign({}, Grid, {\n//   spawn,\n//   next,\n//   hasFree,\n//   nodesByPlayer,\n//   playerGraph,\n//   splitComponents,\n//   allComps,\n//   winegComp,\n// });\n","export const playerInit = { name: '', score: 0 };\nexport default (name = '', score = 0) => ({ name, score });\nexport const name = ({ name }) => name;\nexport const score = ({ score }) => score;\nexport const resetScore = player => player.wins = 0;\nexport const incrementScore = ({ score }) => ++score;\nexport const decrementScore = ({ score }) => --score;\nexport const claim = (player = null) => n => n && Object.assign(n, { player });\n","import { collections, } from 'turmeric-utils';\n\nconst { addBinMap, spread, } = collections;\n\nexport const kvMap = (map = new Map) => fn =>\n  spread(map).map(([ k, v = k ]) => [ k, fn(v) ]).reduce(addBinMap, new Map);\n"],"names":["addMap","collections","get$$1","get","addNodeBin","edges","src","Map","spreadK","spawn","copy","fromElements","_len","arguments","length","elems","Array","_key","reduce","nodes","c","r","player","Object","assign","node","isFree","samePlayer","p0","p1","flatten","flattenBin","a","b","genNodes","cols","rows","generate","map","n","column","row","initNodes","next","find","hasFree","some","nodesByPlayer","graph","filter","playerGraph","gr","p","allComps","colComponents","negComponents","posComponents","rowComponents","f","splitComps","set","g","moreThan","coll","Set","size","num","winComp","playerInit","name","score","resetScore","wins","incrementScore","decrementScore","claim","addBinMap","spread","kvMap","k","v","fn"],"mappings":"+IA2CIA,OAASC,0BAAYD,OACrBE,OAASD,0BAAYE,IASrBC,WAAa,SAAoBC,EAAOC,GAC1C,MAAON,QAAOK,GAAOC,GAAK,GAAIC,KAAIL,OAAOG,GAAOC,MAoC9CE,QAAUP,0BAAYO,QAOtBC,MAAQ,SAAeJ,GACzB,MAAO,IAAIE,KAAIF,IAEbK,KAAOD,MACPE,eAAe,WACjB,IAAK,GAAIC,GAAOC,UAAUC,OAAQC,EAAQC,MAAMJ,GAAOK,EAAO,EAAGA,EAAOL,EAAMK,IAC5EF,EAAME,GAAQJ,UAAUI,EAG1B,OAAOF,GAAMG,OAAOd,WAAYM,SAE9BS,MAAQ,SAAed,GACzB,MAAOG,SAAQE,KAAKL,0BC3GNe,0DAAI,EAAGC,yDAAI,EAAGC,yDAAS,WACvCC,QAAOC,OAAOC,eAAKL,EAAGC,IAAMC,YAEfA,OAAS,sBAAGA,OAAAA,aAAS,aAAWA,IAChCI,OAAS,oBAAGJ,OAAAA,aAAS,aAAsB,QAAXA,GAChCK,WAAa,eAAWC,KAARN,aAAiB,gBAAWO,KAARP,aAAiBM,KAAOC,0pBCFjEC,QAAiC7B,0BAAjC6B,QAEFC,WAAa,cAACC,6DAAQC,kEAAWH,SAAQE,GAAGC,IAIrCC,WAAW,cAACC,0DAAO,EAAGC,yDAAO,QAC1CC,oBAASF,EAAMC,GAAME,IAAI,kBAAKb,QAAKc,EAAEC,OAAQD,EAAEE,QAElCC,UAAY,cAACtB,0DAAI,EAAGC,yDAAI,QAAMV,+CAAgBuB,WAASd,EAAGC,MAC1DsB,KAAO,kBAASxB,GAAMyB,KAAKlB,SAC3BmB,QAAU,kBAAS1B,GAAM2B,KAAKpB,SAE9BqB,cAAgB,kBAAS,eAACzB,0DAAS,WAC9CH,OAAM6B,GAAOC,OAAOtB,YAAaL,cAEtB4B,YAAc,cAACC,0DAAK,GAAI5C,WAAQ,mBAC3CI,+CAAgBoC,cAAcI,GAAIC,OAEvBC,SAAW,mBACtBC,wBAAeC,wBAAeC,wBAAeC,yBAC7CnB,IAAI,kBAAKoB,GAAEV,KAAQ9B,OAAOa,gBAEf4B,WAAa,mBAAK,GAAIpD,MAChCqD,IAAI,MAAOH,wBAAcI,IAAID,IAAI,MAAON,wBAAcO,IACtDD,IAAI,MAAOJ,wBAAcK,IAAID,IAAI,MAAOL,wBAAcM,KAE5CC,SAAW,kBAAO,eAACC,0DAAO,GAAIC,WAAQD,GAAKE,KAAOC,IAClDC,QAAU,SAACnB,MAAOT,0DAAI,QAAMc,UAASL,GAAOF,KAAKgB,SAASvB,mPCjC1D6B,YAAeC,KAAM,GAAIC,MAAO,0BAC7BD,0DAAO,GAAIC,yDAAQ,SAASD,OAAMC,UACrCD,KAAO,iBAAGA,KAAAA,WAAWA,IACrBC,MAAQ,iBAAGA,KAAAA,YAAYA,IACvBC,WAAa,kBAAUjD,GAAOkD,KAAO,GACrCC,eAAiB,eAAGH,KAAAA,cAAcA,GAClCI,eAAiB,eAAGJ,KAAAA,cAAcA,GAClCK,MAAQ,cAACrD,0DAAS,WAAS,mBAAKiB,IAAKhB,OAAOC,OAAOe,GAAKjB,kMCL7DsD,cAAuB3E,0BAAvB2E,UAAWC,WAAY5E,0BAAZ4E,OAENC,MAAQ,cAACxC,0DAAM,GAAI/B,WAAQ,mBACtCsE,YAAOvC,GAAKA,IAAI,uCAAGyC,cAAGC,aAAID,WAAUA,EAAGE,EAAGD,MAAM9D,OAAO0D,cAAW,GAAIrE"}