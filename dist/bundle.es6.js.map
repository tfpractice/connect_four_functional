{"version":3,"file":"bundle.es6.js","sources":["../node_modules/graph-curry/dist/bundle.es6.js","../src/node.js","../src/board.js","../src/player.js","../src/utils/commands.js","../src/game.js"],"sourcesContent":["import { collections } from 'turmeric-utils';\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar addBinMap = collections.addBinMap;\nvar mapDiff = collections.mapDiff;\nvar spread = collections.spread;\nvar addMap = collections.addMap;\nvar get$$1 = collections.get;\nvar flatTuple = collections.flatTuple;\nvar removeMap = collections.removeMap;\n\n\nvar resetNodeBin = function resetNodeBin(edges, src) {\n  return addMap(edges)(src)(new Map());\n};\n\nvar addNodeBin = function addNodeBin(edges, src) {\n  return addMap(edges)(src)(new Map(get$$1(edges)(src)));\n};\n\nvar addEdgeBin = function addEdgeBin(edges, _ref) {\n  var _ref2 = slicedToArray(_ref, 3),\n      src = _ref2[0],\n      nb = _ref2[1],\n      _ref2$ = _ref2[2],\n      wt = _ref2$ === undefined ? 0 : _ref2$;\n\n  return [[src, addMap(get$$1(edges)(src))(nb)(wt)], [nb, addMap(get$$1(edges)(nb))(src)(wt)]].reduce(addBinMap, new Map(edges));\n};\n\nvar removeEdgeBin = function removeEdgeBin(edges, _ref3) {\n  var _ref4 = slicedToArray(_ref3, 2),\n      src = _ref4[0],\n      nb = _ref4[1];\n\n  return [[src, removeMap(get$$1(edges)(src))(nb)], [nb, removeMap(get$$1(edges)(nb))(src)]].reduce(addBinMap, new Map(edges));\n};\n\nvar importEdgeBin = function importEdgeBin(edges, _ref5) {\n  var _ref6 = slicedToArray(_ref5, 2),\n      src = _ref6[0],\n      nbs = _ref6[1];\n\n  return spread(mapDiff(nbs)(get$$1(edges)(src))).map(flatTuple(src)).reduce(addEdgeBin, addNodeBin(edges, src));\n};\n\nvar mergeEdgesBin = function mergeEdgesBin(edges, alts) {\n  return spread(new Map(alts)).reduce(importEdgeBin, edges);\n};\n\nvar triple = collections.triple;\nvar tuple = collections.tuple;\nvar get$2 = collections.get;\nvar spreadK = collections.spreadK;\nvar hasK = collections.hasK;\nvar addBinMap$1 = collections.addBinMap;\nvar removeBin = collections.removeBin;\nvar uniteMap = collections.uniteMap;\n\n\nvar spawn = function spawn(edges) {\n  return new Map(edges);\n};\nvar copy = spawn;\nvar fromElements = function fromElements() {\n  for (var _len = arguments.length, elems = Array(_len), _key = 0; _key < _len; _key++) {\n    elems[_key] = arguments[_key];\n  }\n\n  return elems.reduce(addNodeBin, copy());\n};\nvar nodes = function nodes(edges) {\n  return spreadK(copy(edges));\n};\nvar adj = function adj(edges) {\n  return function (src) {\n    return copy(get$2(edges)(src));\n  };\n};\nvar neighbors = function neighbors(edges) {\n  return function (src) {\n    return nodes(adj(edges)(src));\n  };\n};\nvar contains = function contains(edges) {\n  return function (node) {\n    return hasK(edges)(node);\n  };\n};\nvar isAdjacent = function isAdjacent(edges) {\n  return function (src) {\n    return function (nabe) {\n      return contains(adj(edges)(src))(nabe);\n    };\n  };\n};\n\nvar addNodes = function addNodes(edges) {\n  return function () {\n    for (var _len2 = arguments.length, srcs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      srcs[_key2] = arguments[_key2];\n    }\n\n    return srcs.reduce(addNodeBin, edges);\n  };\n};\nvar removeNodes = function removeNodes(edges) {\n  return function () {\n    for (var _len3 = arguments.length, srcs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      srcs[_key3] = arguments[_key3];\n    }\n\n    return srcs.reduce(removeBin, copy(edges));\n  };\n};\nvar resetNodes = function resetNodes(edges) {\n  return function () {\n    for (var _len4 = arguments.length, srcs = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      srcs[_key4] = arguments[_key4];\n    }\n\n    return srcs.reduce(resetNodeBin, edges);\n  };\n};\n\nvar addEdges = function addEdges(edges) {\n  return function (src) {\n    var w = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return function () {\n      for (var _len5 = arguments.length, nabes = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        nabes[_key5] = arguments[_key5];\n      }\n\n      return nabes.map(triple(w)(src)).reduce(addEdgeBin, edges);\n    };\n  };\n};\n\nvar removeEdges = function removeEdges(edges) {\n  return function (src) {\n    return function () {\n      for (var _len6 = arguments.length, nabes = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        nabes[_key6] = arguments[_key6];\n      }\n\n      return nabes.map(tuple(src)).reduce(removeEdgeBin, edges);\n    };\n  };\n};\n\nvar mergeEdges = function mergeEdges(edges) {\n  return function () {\n    for (var _len7 = arguments.length, alts = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      alts[_key7] = arguments[_key7];\n    }\n\n    return alts.reduce(mergeEdgesBin, edges);\n  };\n};\n\nvar addNeighbor = function addNeighbor(edges) {\n  return function (src) {\n    return function (n) {\n      var w = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return addBinMap$1(adj(edges)(src), [n, w]);\n    };\n  };\n};\n\nvar addEntry = function addEntry(nabes) {\n  return function (_ref) {\n    var _ref2 = slicedToArray(_ref, 2),\n        n = _ref2[0],\n        _ref2$ = _ref2[1],\n        w = _ref2$ === undefined ? 0 : _ref2$;\n\n    return addBinMap$1(nabes, [n, w]);\n  };\n};\n\nvar mergeNeighbors = uniteMap;\n\nvar addBinSet = collections.addBinSet;\nvar lastK = collections.lastK;\nvar hasK$1 = collections.hasK;\nvar mapDiff$1 = collections.mapDiff;\nvar diff = collections.diff;\nvar addBinMap$2 = collections.addBinMap;\nvar spread$1 = collections.spread;\nvar spreadK$1 = collections.spreadK;\nvar spreadV = collections.spreadV;\nvar popFirst = collections.popFirst;\nvar tuple$1 = collections.tuple;\n\n\nvar pathVal = function pathVal() {\n  var pred = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  return function () {\n    var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    return function () {\n      var weight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return { pred: pred, length: length, weight: weight };\n    };\n  };\n};\n\nvar addSrc = function addSrc() {\n  var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Map();\n  return function (src) {\n    return path.set(src, { pred: lastK(path), weight: 0, length: 1 });\n  };\n};\n\nvar initPath = function initPath(node) {\n  return addSrc()(node);\n};\nvar ptW = function ptW(_ref) {\n  var _ref$weight = _ref.weight,\n      weight = _ref$weight === undefined ? 0 : _ref$weight;\n  return weight;\n};\nvar ptL = function ptL(_ref2) {\n  var _ref2$length = _ref2.length,\n      length = _ref2$length === undefined ? 1 : _ref2$length;\n  return length;\n};\nvar lastVal = function lastVal(path) {\n  return path.get(lastK(path));\n};\nvar lastW = function lastW(path) {\n  return ptW(lastVal(path));\n};\nvar lastL = function lastL(path) {\n  return ptL(lastVal(path));\n};\nvar nextW = function nextW(path) {\n  return function () {\n    var w = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return lastW(path) + w;\n  };\n};\nvar nextL = function nextL(path) {\n  return lastL(path) ? lastL(path) + 1 : 1;\n};\n\nvar nextPath = function nextPath() {\n  var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Map();\n  var _ref3 = arguments[1];\n\n  var _ref4 = slicedToArray(_ref3, 2),\n      n = _ref4[0],\n      _ref4$ = _ref4[1],\n      w = _ref4$ === undefined ? 0 : _ref4$;\n\n  return path.set(n, pathVal(lastK(path))(nextL(path))(nextW(path)(w)));\n};\n\nvar dfs = function dfs(edges) {\n  return function (src) {\n    var trav = function trav() {\n      var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initPath(src);\n\n      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [lastK(path), 0],\n          _ref6 = slicedToArray(_ref5, 2),\n          n = _ref6[0],\n          w = _ref6[1];\n\n      return spread$1(mapDiff$1(edges.get(n))(path)).reduce(trav, nextPath(path, [n, w]));\n    };\n\n    return trav(initPath(src));\n  };\n};\n\nvar bfs = function bfs(edges) {\n  return function (iNode) {\n    var bVisit = function bVisit(bPath) {\n      return function (bQueue) {\n        var pred = popFirst(bQueue);\n        var nextNabes = mapDiff$1(edges.get(pred))(bPath);\n\n        spread$1(nextNabes).reduce(nextPath, bPath);\n        spreadK$1(nextNabes).reduce(addBinSet, bQueue);\n        return bQueue.size > 0 ? bVisit(bPath)(bQueue) : bPath;\n      };\n    };\n\n    return bVisit(initPath(iNode))(new Set([iNode]));\n  };\n};\n\nvar dijkstra = function dijkstra(edges) {\n  return function (iNode) {\n    var reachables = bfs(edges)(iNode);\n    var inspectQueue = new Set([iNode]);\n    var solutionSet = initPath(iNode);\n\n    while (inspectQueue.size > 0) {\n      var pred = popFirst(inspectQueue);\n      var nextNabes = edges.get(pred);\n\n      var _solutionSet$get = solutionSet.get(pred),\n          dCount = _solutionSet$get.length,\n          dWeight = _solutionSet$get.weight;\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n\n        for (var _iterator = nextNabes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _step$value = slicedToArray(_step.value, 2),\n              nabe = _step$value[0],\n              nWeight = _step$value[1];\n\n          var prevMap = reachables.get(nabe) || { length: 1, weight: 0 };\n          var rCount = prevMap.length,\n              rWeight = prevMap.weight;\n\n          var dMap = { pred: pred, length: dCount + 1, weight: dWeight + nWeight };\n          var sMap = dWeight + nWeight < rWeight ? dMap : prevMap;\n\n          if (!solutionSet.has(nabe)) {\n            inspectQueue.add(nabe);\n            solutionSet.set(nabe, sMap);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n\n    return solutionSet;\n  };\n};\n\nvar components = function components(edges) {\n  var trav = function trav() {\n    var comp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Set();\n    var node = arguments[1];\n    return diff(spreadK$1(edges.get(node)))(comp).reduce(trav, comp.add(node));\n  };\n  var visitMap = function visitMap() {\n    var mMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Map();\n    var node = arguments[1];\n    return diff(trav(new Set(), node))(mMap).map(tuple$1(trav(new Set(), node))).reduce(addBinMap$2, mMap);\n  };\n\n  return spreadK$1(edges).reduce(visitMap, new Map());\n};\n\nvar componentSet = function componentSet(edges) {\n  return new Set(spreadV(components(edges)));\n};\nvar pathBetween = function pathBetween(edges) {\n  return function (n0) {\n    return function (n1) {\n      return hasK$1(components(edges).get(n1))(n0);\n    };\n  };\n};\n\nvar spread$2 = collections.spread;\nvar spreadK$2 = collections.spreadK;\nvar spreadV$1 = collections.spreadV;\nvar spreadKV = collections.spreadKV;\nvar last = collections.last;\n\n\nvar redStr = function redStr() {\n  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ' ';\n  var val = arguments[1];\n  var id = arguments[2];\n  var coll = arguments[3];\n  return val === last(coll) ? str.concat(val, ' ') : str.concat(val, ' , ');\n};\nvar collString = function collString(coll) {\n  return spread$2(coll).reduce(redStr, '');\n};\nvar kString = function kString(coll) {\n  return spreadK$2(coll).reduce(redStr, '');\n};\nvar vString = function vString(coll) {\n  return spreadV$1(coll).reduce(redStr, '');\n};\nvar kvString = function kvString(coll) {\n  return spreadKV(coll).reduce(redStr, '');\n};\n\nvar pathString = function pathString(path) {\n  return ' { ' + spreadK$2(path).join(' => ') + ' }';\n};\nvar edgeString = function edgeString(_ref) {\n  var _ref2 = slicedToArray(_ref, 2),\n      src = _ref2[0],\n      nbs = _ref2[1];\n\n  return '{ Edge ' + src + ' >> [ ' + kString(nbs) + ' ] } ';\n};\n\nvar componentString = function componentString(_ref3) {\n  var _ref4 = slicedToArray(_ref3, 2),\n      node = _ref4[0],\n      nbs = _ref4[1];\n\n  return '{ component ' + node + ' >> [ ' + kString(nbs) + ' ] } ';\n};\n\nvar graphString = function graphString(edges) {\n  return spreadKV(edges).reduce(function (str, _ref5, id) {\n    var _ref6 = slicedToArray(_ref5, 2),\n        node = _ref6[0],\n        nabes = _ref6[1];\n\n    return str + edgeString([node, nabes]);\n  }, 'Showing Edges\\n');\n};\n\nvar showGraph = function showGraph(_ref7) {\n  var edges = _ref7.edges;\n  return graphString(edges);\n};\n\n// export { Graph, Reducers, Search, Show, };\n\nexport { resetNodeBin, addNodeBin, addEdgeBin, removeEdgeBin, importEdgeBin, mergeEdgesBin, spawn, copy, fromElements, nodes, adj, neighbors, contains, isAdjacent, addNodes, removeNodes, resetNodes, addEdges, removeEdges, mergeEdges, addNeighbor, addEntry, mergeNeighbors, dfs, bfs, dijkstra, components, componentSet, pathBetween, redStr, collString, kString, vString, kvString, pathString, edgeString, componentString, graphString, showGraph };export default fromElements;\n//# sourceMappingURL=bundle.es6.js.map\n","import { node, } from 'game_grid';\n\nexport default (c = 0, r = 0, player = null) =>\nObject.assign(node(c, r), { player });\n\nexport const player = ({ player = null }) => player;\nexport const isFree = ({ player = null }) => player === null;\nexport const samePlayer = ({ player: p0 }) => ({ player: p1 }) => p0 === p1;\n","import { collections, } from 'turmeric-utils';\nimport { fromElements, nodes, } from 'graph-curry';\nimport { colComponents, genNodes as generate, grid, negComponents,\n   posComponents, rowComponents, } from 'game_grid';\nimport node, { isFree, samePlayer, } from './node';\nconst { flatten, flatTuple, spreadV, } = collections;\n\nconst flattenBin = (a = [], b = []) => flatten(a)(b);\n\nexport default fromElements;\n\nexport const genNodes = (cols = 7, rows = 6) =>\ngenerate(cols, rows).map(n => node(n.column, n.row));\n\nexport const initNodes = (c = 7, r = 6) => fromElements(...genNodes(c, r));\nexport const next = nodes => nodes.find(isFree);\nexport const hasFree = nodes => nodes.some(isFree);\n\nexport const nodesByPlayer = graph => (player = null) =>\n  nodes(graph).filter(samePlayer({ player }));\n\nexport const playerGraph = (gr = new Map) => p =>\n  fromElements(...nodesByPlayer(gr)(p));\n\nexport const allComps = graph => [\n  colComponents, negComponents, posComponents, rowComponents,\n].map(f => f(graph)).reduce(flattenBin, []);\n\nexport const splitComps = g => new Map()\n  .set('row', rowComponents(g)).set('col', colComponents(g))\n  .set('pos', posComponents(g)).set('neg', negComponents(g));\n\nexport const moreThan = num => (coll = new Set) => coll.size > num;\nexport const winComp = (graph, n = 3) => allComps(graph).some(moreThan(n));\n","export const playerInit = { name: '', score: 0 };\nexport default (name = '', score = 0) => ({ name, score });\nexport const name = ({ name }) => name;\nexport const score = ({ score }) => score;\nexport const resetScore = player => player.wins = 0;\nexport const incrementScore = ({ score }) => ++score;\nexport const decrementScore = ({ score }) => --score;\nexport const claim = (player = null) => n => n && Object.assign(n, { player });\n","import { collections, } from 'turmeric-utils';\n\nconst { addBinMap, spread, } = collections;\n\nexport const kvMap = (map = new Map) => fn =>\n  spread(map).map(([ k, v = k ]) => [ k, fn(v) ]).reduce(addBinMap, new Map);\n","\nimport { kvMap, } from './utils';\nimport { collections, } from 'turmeric-utils';\nimport { nodesByColumn, } from 'game_grid';\nimport player, { claim, } from './player';\nimport makeBoard, { allComps, next as bnext, genNodes, hasFree, playerGraph as pGraph,\n   splitComps, winComp, } from './board';\nconst { spreadKV } = collections;\n\nconst initGame = () => ({\n  cID: 0,\n  nodes: genNodes(),\n  players: [ player('player0'), player('player1') ],\n});\n\nexport default ({ cID = 0, nodes = genNodes(), players = initGame().players }) =>\n ({ cID, nodes, players, });\n\nexport const setPlayers = players => (g = initGame()) =>\nObject.assign({}, g, players);\nexport const cID = ({ cID = 0 }) => cID;\nexport const board = ({ nodes }) => makeBoard(...nodes);\nexport const players = ({ players }) => players;\nexport const active = ({ players: [ active, passive ] }) => active;\nexport const passive = ({ players: [ active, passive ] }) => passive;\n\nexport const column = ({ cID, nodes }) => nodesByColumn(board({ nodes }))(cID);\nexport const next = game => bnext(column(game));\nexport const playerMap = players => new Map(spreadKV(new Set(players)));\n\nexport const graphs = ({ players: p, nodes }) =>\n  kvMap(playerMap(p))(pGraph(board({ nodes })));\nexport const actGraph = ({ players: [ act, pass ], nodes }) =>\n  pGraph(board({ nodes }))(act);\nexport const passGraph = ({ players: [ act, pass ], nodes }) =>\n  pGraph(board({ nodes }))(pas);\n\nexport const components = game => kvMap(graphs(game))(splitComps);\nexport const actComps = game => allComps(actGraph(game));\nexport const passComps = game => allComps(passGraph(game));\n\nexport const togglePlayers = ({ players: arr }) =>\n[ arr[1], arr[0] ] = [ arr[0], arr[1] ];\n\nexport const setColumn = game => (cID = 0) => Object.assign(game, { cID });\nexport const select = game => claim(active(game))(next(game)) && togglePlayers(game);\nexport const hasWinComp = brd => plr => winComp(pGraph(brd)(plr), 3);\nexport const winner = ({ players, nodes }) => players.find(hasWinComp(board({ nodes })));\n"],"names":["c","r","player","Object","assign","node","isFree","samePlayer","p0","p1","flatten","collections","flattenBin","a","b","genNodes","cols","rows","generate","map","n","column","row","initNodes","fromElements","next","nodes","find","hasFree","some","nodesByPlayer","graph","filter","playerGraph","gr","Map","p","allComps","colComponents","negComponents","posComponents","rowComponents","f","reduce","splitComps","set","g","moreThan","coll","Set","size","num","winComp","playerInit","name","score","resetScore","wins","incrementScore","decrementScore","claim","addBinMap","spread","kvMap","k","v","fn","spreadKV","initGame","cID","players","setPlayers","board","makeBoard","active","passive","nodesByColumn","bnext","game","playerMap","graphs","pGraph","actGraph","act","pass","passGraph","pas","components","actComps","passComps","togglePlayers","arr","setColumn","select","hasWinComp","brd","plr","winner"],"mappings":";;;AA2CA,IAAI,MAAM,GAAG,WAAW,CAAC,MAAM,CAAC;AAChC,IAAI,MAAM,GAAG,WAAW,CAAC,GAAG,CAAC;AAC7B,AAAI,AAAS,AACb,AAGA,AAIA,IAAI,UAAU,GAAG,SAAS,UAAU,CAAC,KAAK,EAAE,GAAG,EAAE;EAC/C,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;CACxD,CAAC;;AAEF,AACE,AAMA,AAGF,AACE,AAIA,AAGF,AACE,AAIA,AAAoD,AAAS,AAG/D,AAIA,AACA,AACA,AACA,IAAI,OAAO,GAAG,WAAW,CAAC,OAAO,CAAC;AAClC,AACA,AACA,AACA,AAGA,IAAI,KAAK,GAAG,SAAS,KAAK,CAAC,KAAK,EAAE;EAChC,OAAO,IAAI,GAAG,CAAC,KAAK,CAAC,CAAC;CACvB,CAAC;AACF,IAAI,IAAI,GAAG,KAAK,CAAC;AACjB,IAAI,YAAY,GAAG,SAAS,YAAY,GAAG;EACzC,KAAK,IAAI,IAAI,GAAG,SAAS,CAAC,MAAM,EAAE,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE,IAAI,GAAG,CAAC,EAAE,IAAI,GAAG,IAAI,EAAE,IAAI,EAAE,EAAE;IACpF,KAAK,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC,IAAI,CAAC,CAAC;GAC/B;;EAED,OAAO,KAAK,CAAC,MAAM,CAAC,UAAU,EAAE,IAAI,EAAE,CAAC,CAAC;CACzC,CAAC;AACF,IAAI,KAAK,GAAG,SAAS,KAAK,CAAC,KAAK,EAAE;EAChC,OAAO,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;CAC7B,CAAC,AACF,AAKA,AAKA,AACmB,AAAI,AACA,AAAI,AAG3B,AAQA,AAEI,AAIA,AAGJ,AAEI,AAIA,AAGJ,AAEI,AAIA,AAIJ,AAEI,AACA,AACE,AAIA,AAKN,AAGM,AAIA,AAKN,AAEI,AAIA,AAIJ,AAGM,AACA,AAKN,AAEI,AAKA,AAIJ,AAEA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AAAI,AAAO,AACX,AACA,AAGA,AACE,AACA,AACE,AACA,AACE,AACA,AAKN,AACE,AACA,AAKF,AAAiC,AAAI,AACnB,AAAI,AAEtB,AACE,AAEA,AAEF,AACE,AAEA,AAEF,AAGA,AAGA,AAGA,AAEI,AACA,AAGJ,AAIA,AACE,AACA,AAEA,AAKA,AAGF,AAEI,AACE,AAEA,AAKA,AAGF,AAIJ,AAEI,AAEI,AACA,AAEA,AACA,AACA,AAIJ,AAIJ,AAEI,AACA,AACA,AAEA,AA+CA,AAIJ,AACE,AACE,AACA,AAAI,AAAI,AACR,AAAgC,AAAI,AAAgC,AAAI,AAE1E,AACE,AACA,AAAI,AAAI,AACR,AAA4B,AAAI,AAAqC,AAAI,AAG3E,AAGF,AACiB,AAAO,AAExB,AAQA,AACA,AACA,AAAI,AAAS,AACb,AACA,AAGA,AACE,AACA,AACA,AACA,AACA,AAEF,AAGA,AAGA,AACS,AAAS,AAElB,AAIA,AAGA,AACE,AAIA,AAGF,AACE,AACI,AAAI,AAGR,AAAwB,AAAI,AAG9B,AAEI,AACI,AAAI,AAGR,AAAyB,AAAI,AAIjC,AACE,AACA,AAGF,AAE8b,AAA4B,AAC1d,AAAsC;;ACzdtC,cAAe;MAACA,CAAD,uEAAK,CAAL;MAAQC,CAAR,uEAAY,CAAZ;MAAeC,MAAf,uEAAwB,IAAxB;SACfC,OAAOC,MAAP,CAAcC,KAAKL,CAAL,EAAQC,CAAR,CAAd,EAA0B,EAAEC,cAAF,EAA1B,CADe;CAAf;;AAGA,AAAO,IAAMA,SAAS;yBAAGA,MAAH;MAAGA,MAAH,+BAAY,IAAZ;SAAuBA,MAAvB;CAAf;AACP,AAAO,IAAMI,SAAS,SAATA,MAAS;2BAAGJ,MAAH;MAAGA,MAAH,gCAAY,IAAZ;SAAuBA,WAAW,IAAlC;CAAf;AACP,AAAO,IAAMK,aAAa,SAAbA,UAAa;MAAWC,EAAX,SAAGN,MAAH;SAAoB;QAAWO,EAAX,SAAGP,MAAH;WAAoBM,OAAOC,EAA3B;GAApB;CAAnB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICFCC,UAAiCC,YAAjCD;;;AAER,IAAME,aAAa,SAAbA,UAAa;MAACC,CAAD,uEAAK,EAAL;MAASC,CAAT,uEAAa,EAAb;SAAoBJ,QAAQG,CAAR,EAAWC,CAAX,CAApB;CAAnB;;AAEA,AAEA,AAAO,IAAMC,aAAW,SAAXA,WAAW;MAACC,IAAD,uEAAQ,CAAR;MAAWC,IAAX,uEAAkB,CAAlB;SACxBC,SAASF,IAAT,EAAeC,IAAf,EAAqBE,GAArB,CAAyB;WAAKd,OAAKe,EAAEC,MAAP,EAAeD,EAAEE,GAAjB,CAAL;GAAzB,CADwB;CAAjB;;AAGP,AAAO,IAAMC,YAAY,SAAZA,SAAY;MAACvB,CAAD,uEAAK,CAAL;MAAQC,CAAR,uEAAY,CAAZ;SAAkBuB,gDAAgBT,WAASf,CAAT,EAAYC,CAAZ,CAAhB,EAAlB;CAAlB;AACP,AAAO,IAAMwB,OAAO,SAAPA,IAAO;SAASC,SAAMC,IAAN,CAAWrB,MAAX,CAAT;CAAb;AACP,AAAO,IAAMsB,UAAU,SAAVA,OAAU;SAASF,SAAMG,IAAN,CAAWvB,MAAX,CAAT;CAAhB;;AAEP,AAAO,IAAMwB,gBAAgB,SAAhBA,aAAgB;SAAS;QAAC5B,SAAD,uEAAU,IAAV;WACpCwB,MAAMK,KAAN,EAAaC,MAAb,CAAoBzB,WAAW,EAAEL,iBAAF,EAAX,CAApB,CADoC;GAAT;CAAtB;;AAGP,AAAO,IAAM+B,cAAc,SAAdA,WAAc;MAACC,EAAD,uEAAM,IAAIC,GAAJ,EAAN;SAAkB;WAC3CX,gDAAgBM,cAAcI,EAAd,EAAkBE,CAAlB,CAAhB,EAD2C;GAAlB;CAApB;;AAGP,AAAO,IAAMC,WAAW,SAAXA,QAAW;SAAS,CAC/BC,aAD+B,EAChBC,aADgB,EACDC,aADC,EACcC,aADd,EAE/BtB,GAF+B,CAE3B;WAAKuB,EAAEX,KAAF,CAAL;GAF2B,EAEZY,MAFY,CAEL/B,UAFK,EAEO,EAFP,CAAT;CAAjB;;AAIP,AAAO,IAAMgC,aAAa,SAAbA,UAAa;SAAK,IAAIT,GAAJ,GAC5BU,GAD4B,CACxB,KADwB,EACjBJ,cAAcK,CAAd,CADiB,EACCD,GADD,CACK,KADL,EACYP,cAAcQ,CAAd,CADZ,EAE5BD,GAF4B,CAExB,KAFwB,EAEjBL,cAAcM,CAAd,CAFiB,EAECD,GAFD,CAEK,KAFL,EAEYN,cAAcO,CAAd,CAFZ,CAAL;CAAnB;;AAIP,AAAO,IAAMC,WAAW,SAAXA,QAAW;SAAO;QAACC,IAAD,uEAAQ,IAAIC,GAAJ,EAAR;WAAoBD,KAAKE,IAAL,GAAYC,GAAhC;GAAP;CAAjB;AACP,AAAO,IAAMC,UAAU,SAAVA,OAAU,CAACrB,KAAD;MAAQX,CAAR,uEAAY,CAAZ;SAAkBiB,SAASN,KAAT,EAAgBF,IAAhB,CAAqBkB,SAAS3B,CAAT,CAArB,CAAlB;CAAhB;;;;;;;;;;;;;;;;;;ACjCA,IAAMiC,aAAa,EAAEC,MAAM,EAAR,EAAYC,OAAO,CAAnB,EAAnB;AACP,gBAAe;MAACD,IAAD,uEAAQ,EAAR;MAAYC,KAAZ,uEAAoB,CAApB;SAA2B,EAAED,UAAF,EAAQC,YAAR,EAA3B;CAAf;AACA,AAAO,IAAMD,OAAO;MAAGA,IAAH,QAAGA,IAAH;SAAcA,IAAd;CAAb;AACP,AAAO,IAAMC,QAAQ;MAAGA,KAAH,SAAGA,KAAH;SAAeA,KAAf;CAAd;AACP,AAAO,IAAMC,aAAa,SAAbA,UAAa;SAAUtD,OAAOuD,IAAP,GAAc,CAAxB;CAAnB;AACP,AAAO,IAAMC,iBAAiB,SAAjBA,cAAiB;MAAGH,KAAH,SAAGA,KAAH;SAAe,EAAEA,KAAjB;CAAvB;AACP,AAAO,IAAMI,iBAAiB,SAAjBA,cAAiB;MAAGJ,KAAH,SAAGA,KAAH;SAAe,EAAEA,KAAjB;CAAvB;AACP,AAAO,IAAMK,QAAQ,SAARA,KAAQ;MAAC1D,MAAD,uEAAU,IAAV;SAAmB;WAAKkB,KAAKjB,OAAOC,MAAP,CAAcgB,CAAd,EAAiB,EAAElB,cAAF,EAAjB,CAAV;GAAnB;CAAd;;;;;;;;;;;;;ICLC2D,gBAAuBlD,YAAvBkD;IAAWC,aAAYnD,YAAZmD;;;AAEnB,AAAO,IAAMC,QAAQ,SAARA,KAAQ;MAAC5C,GAAD,uEAAO,IAAIgB,GAAJ,EAAP;SAAmB;WACtC2B,WAAO3C,GAAP,EAAYA,GAAZ,CAAgB;;UAAG6C,CAAH;;UAAMC,CAAN,0BAAUD,CAAV;;aAAkB,CAAEA,CAAF,EAAKE,GAAGD,CAAH,CAAL,CAAlB;KAAhB,EAAgDtB,MAAhD,CAAuDkB,aAAvD,EAAkE,IAAI1B,GAAJ,EAAlE,CADsC;GAAnB;CAAd;;ICGCgC,aAAaxD,YAAbwD;;;AAER,IAAMC,WAAW,SAAXA,QAAW;SAAO;SACjB,CADiB;WAEfrD,YAFe;aAGb,CAAEb,SAAO,SAAP,CAAF,EAAqBA,SAAO,SAAP,CAArB;GAHM;CAAjB;;AAMA,YAAe;sBAAGmE,GAAH;MAAGA,GAAH,4BAAS,CAAT;wBAAY3C,KAAZ;MAAYA,KAAZ,8BAAoBX,YAApB;0BAAgCuD,OAAhC;MAAgCA,OAAhC,gCAA0CF,WAAWE,OAArD;SACb,EAAED,QAAF,EAAO3C,YAAP,EAAc4C,gBAAd,EADa;CAAf;;AAGA,AAAO,IAAMC,aAAa,SAAbA,UAAa;SAAW;QAACzB,CAAD,uEAAKsB,UAAL;WACrCjE,OAAOC,MAAP,CAAc,EAAd,EAAkB0C,CAAlB,EAAqBwB,OAArB,CADqC;GAAX;CAAnB;AAEP,AAAO,IAAMD,MAAM;wBAAGA,GAAH;MAAGA,GAAH,6BAAS,CAAT;SAAiBA,GAAjB;CAAZ;AACP,AAAO,IAAMG,UAAQ,SAARA,KAAQ;MAAG9C,KAAH,SAAGA,KAAH;SAAe+C,gDAAa/C,KAAb,EAAf;CAAd;AACP,AAAO,IAAM4C,UAAU;MAAGA,OAAH,SAAGA,OAAH;SAAiBA,OAAjB;CAAhB;AACP,AAAO,IAAMI,SAAS;4CAAGJ,OAAH;MAAcI,MAAd;MAAsBC,OAAtB;;SAAsCD,MAAtC;CAAf;AACP,AAAO,IAAMC,UAAU;4CAAGL,OAAH;MAAcI,MAAd;MAAsBC,OAAtB;;SAAsCA,OAAtC;CAAhB;;AAEP,AAAO,IAAMtD,SAAS,SAATA,MAAS;MAAGgD,GAAH,SAAGA,GAAH;MAAQ3C,KAAR,SAAQA,KAAR;SAAoBkD,cAAcJ,QAAM,EAAE9C,YAAF,EAAN,CAAd,EAAgC2C,GAAhC,CAApB;CAAf;AACP,AAAO,IAAM5C,SAAO,SAAPA,OAAO;SAAQoD,KAAMxD,OAAOyD,IAAP,CAAN,CAAR;CAAb;AACP,AAAO,IAAMC,YAAY,SAAZA,SAAY;SAAW,IAAI5C,GAAJ,CAAQgC,WAAS,IAAIlB,GAAJ,CAAQqB,OAAR,CAAT,CAAR,CAAX;CAAlB;;AAEP,AAAO,IAAMU,SAAS,SAATA,MAAS;MAAY5C,CAAZ,SAAGkC,OAAH;MAAe5C,KAAf,SAAeA,KAAf;SACpBqC,MAAMgB,UAAU3C,CAAV,CAAN,EAAoB6C,YAAOT,QAAM,EAAE9C,YAAF,EAAN,CAAP,CAApB,CADoB;CAAf;AAEP,AAAO,IAAMwD,WAAW,SAAXA,QAAW;4CAAGZ,OAAH;MAAca,GAAd;MAAmBC,IAAnB;MAA2B1D,KAA3B,SAA2BA,KAA3B;;SACtBuD,YAAOT,QAAM,EAAE9C,YAAF,EAAN,CAAP,EAAyByD,GAAzB,CADsB;CAAjB;AAEP,AAAO,IAAME,YAAY,SAAZA,SAAY;8CAAGf,OAAH;MAAca,GAAd;MAAmBC,IAAnB;MAA2B1D,KAA3B,UAA2BA,KAA3B;;SACvBuD,YAAOT,QAAM,EAAE9C,YAAF,EAAN,CAAP,EAAyB4D,GAAzB,CADuB;CAAlB;;AAGP,AAAO,IAAMC,eAAa,SAAbA,UAAa;SAAQxB,MAAMiB,OAAOF,IAAP,CAAN,EAAoBlC,UAApB,CAAR;CAAnB;AACP,AAAO,IAAM4C,WAAW,SAAXA,QAAW;SAAQnD,SAAS6C,SAASJ,IAAT,CAAT,CAAR;CAAjB;AACP,AAAO,IAAMW,YAAY,SAAZA,SAAY;SAAQpD,SAASgD,UAAUP,IAAV,CAAT,CAAR;CAAlB;;AAEP,AAAO,IAAMY,gBAAgB,SAAhBA,aAAgB;;;MAAYC,GAAZ,UAAGrB,OAAH;kBACR,CAAEqB,IAAI,CAAJ,CAAF,EAAUA,IAAI,CAAJ,CAAV,CADQ,EAC3BA,IAAI,CAAJ,CAD2B,cACnBA,IAAI,CAAJ,CADmB;CAAtB;;AAGP,AAAO,IAAMC,YAAY,SAAZA,SAAY;SAAQ;QAACvB,GAAD,uEAAO,CAAP;WAAalE,OAAOC,MAAP,CAAc0E,IAAd,EAAoB,EAAET,QAAF,EAApB,CAAb;GAAR;CAAlB;AACP,AAAO,IAAMwB,SAAS,SAATA,MAAS;SAAQjC,MAAMc,OAAOI,IAAP,CAAN,EAAoBrD,OAAKqD,IAAL,CAApB,KAAmCY,cAAcZ,IAAd,CAA3C;CAAf;AACP,AAAO,IAAMgB,aAAa,SAAbA,UAAa;SAAO;WAAO1C,QAAQ6B,YAAOc,GAAP,EAAYC,GAAZ,CAAR,EAA0B,CAA1B,CAAP;GAAP;CAAnB;AACP,AAAO,IAAMC,SAAS,SAATA,MAAS;MAAG3B,OAAH,UAAGA,OAAH;MAAY5C,KAAZ,UAAYA,KAAZ;SAAwB4C,QAAQ3C,IAAR,CAAamE,WAAWtB,QAAM,EAAE9C,YAAF,EAAN,CAAX,CAAb,CAAxB;CAAf;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}